// MalwareWhackMiniGame.js - Mini game for the malware threat
class MalwareWhackMiniGame extends Phaser.Scene {
  constructor() {
    super("MalwareWhackMiniGame");
    this.timeLeft = 30; // 30 seconds time limit
    this.score = 0;
    this.systemHealth = 100;
    this.comboCount = 0;
    this.maxComboCount = 0;
    this.gameState = "initializing"; // initializing, playing, gameOver
    this.threatType = "malware";

    // Spawn parameters
    this.spawnDelay = 2000; // ms between spawns at start
    this.minSpawnDelay = 600; // minimum spawn delay (gets faster over time)
    this.itemLifespan = 3000; // how long items stay on screen
    this.itemsSpawned = 0;
    this.malwareClicked = 0;
    this.malwareMissed = 0;
    this.legitimateClicked = 0;

    // Game objects
    this.activeItems = [];

    // Define malware types with their icons and colors
    this.MALWARE_TYPES = {
      virus: { name: "Virus", icon: "ü¶†", color: 0xef4444, points: 10 },
      trojan: { name: "Trojan", icon: "üê¥", color: 0x92400e, points: 10 },
      worm: { name: "Worm", icon: "üêõ", color: 0x15803d, points: 10 },
      ransomware: {
        name: "Ransomware",
        icon: "üîí",
        color: 0xc2410c,
        points: 15,
      },
      spyware: { name: "Spyware", icon: "üïµÔ∏è", color: 0xa855f7, points: 10 },
      rootkit: { name: "Rootkit", icon: "üå±", color: 0x0f766e, points: 15 },
      keylogger: { name: "Keylogger", icon: "‚å®Ô∏è", color: 0xb91c1c, points: 10 },
      adware: { name: "Adware", icon: "üì¢", color: 0xca8a04, points: 5 },
    };

    // Define legitimate files with their icons and penalty points
    this.LEGITIMATE_FILES = {
      document: { name: "Document", icon: "üìÑ", color: 0x3b82f6, penalty: 5 },
      image: { name: "Image", icon: "üñºÔ∏è", color: 0x22c55e, penalty: 5 },
      folder: { name: "Folder", icon: "üìÅ", color: 0xf59e0b, penalty: 5 },
      application: {
        name: "Application",
        icon: "üì¶",
        color: 0xd97706,
        penalty: 5,
      },
      pdf: { name: "PDF", icon: "üìë", color: 0xdc2626, penalty: 5 },
      music: { name: "Music", icon: "üéµ", color: 0x8b5cf6, penalty: 5 },
      video: { name: "Video", icon: "üé¨", color: 0x10b981, penalty: 5 },
    };
  }

  init(data) {
    // Receive data from the main game
    this.mainScene = data.mainScene;
    this.row = data.row;
    this.col = data.col;
    this.score = data.score || 0;
    this.returnCallback = data.callback;
  }

  create() {
    const { width, height } = this.cameras.main;

    // Create background (desktop environment)
    this.createBackground();

    // Create UI
    this.createUI();

    // Create game area - central area for items to appear
    this.gameAreaWidth = width - 100;
    this.gameAreaHeight = height - 200;
    this.gameAreaX = 50;
    this.gameAreaY = 120;

    // Initialize arrays for active items
    this.activeItems = [];

    // Start countdown
    this.startCountdown();
  }

  createBackground() {
    const { width, height } = this.cameras.main;

    // Desktop background
    this.add.rectangle(0, 0, width, height, 0x062c43).setOrigin(0);

    // Desktop grid for icons (faint)
    const gridGraphics = this.add.graphics();
    gridGraphics.lineStyle(1, 0x0c4a6e, 0.1);

    // Grid lines
    const cellSize = 80;
    for (let x = 0; x < width; x += cellSize) {
      gridGraphics.lineBetween(x, 0, x, height);
    }
    for (let y = 0; y < height; y += cellSize) {
      gridGraphics.lineBetween(0, y, width, y);
    }

    // Add some desktop elements
    // Taskbar
    this.add.rectangle(0, height - 40, width, 40, 0x0c4a6e).setOrigin(0);

    // Start button
    this.add.rectangle(10, height - 30, 30, 20, 0x0284c7).setOrigin(0, 0.5);

    // Taskbar icons
    const iconY = height - 20;
    for (let i = 0; i < 5; i++) {
      this.add.rectangle(60 + i * 40, iconY, 30, 30, 0x075985).setOrigin(0.5);
    }

    // Desktop icons (randomly placed)
    const numIcons = 8;
    for (let i = 0; i < numIcons; i++) {
      // Generate non-overlapping positions at grid intersections
      const x =
        40 + Math.floor(Math.random() * (width / cellSize - 1)) * cellSize;
      const y =
        40 +
        Math.floor(Math.random() * ((height - 40) / cellSize - 1)) * cellSize;

      // Icon background
      this.add.rectangle(x, y, 50, 50, 0x0c4a6e, 0.2).setOrigin(0.5);

      // Random icon
      const icons = ["üìÑ", "üñºÔ∏è", "üìÅ", "üì¶", "üìë", "üéµ", "üé¨"];
      const randomIcon = icons[Math.floor(Math.random() * icons.length)];
      this.add.text(x, y, randomIcon, { font: "24px Arial" }).setOrigin(0.5);
    }
  }

  createUI() {
    const { width, height } = this.cameras.main;

    // Game title
    this.add
      .text(width / 2, 30, "MALWARE WHACK!", {
        font: "bold 32px Arial",
        fill: "#00ff66",
        stroke: "#000",
        strokeThickness: 4,
      })
      .setOrigin(0.5);

    // Instructions
    this.add
      .text(width / 2, 70, "Click on malware icons! Avoid legitimate files!", {
        font: "16px Arial",
        fill: "#ffffff",
      })
      .setOrigin(0.5);

    // Create timer display
    this.timerText = this.add
      .text(width / 2, 100, `Time: ${this.timeLeft}s`, {
        font: "bold 20px Arial",
        fill: "#ffdd00",
      })
      .setOrigin(0.5);

    // Create score display
    this.scoreText = this.add
      .text(width - 120, 30, `Score: ${this.score}`, {
        font: "18px Arial",
        fill: "#00cc66",
      })
      .setOrigin(0.5);

    // Create health bar background
    this.add.rectangle(120, 30, 150, 20, 0x222222).setStrokeStyle(1, 0x444444);

    // Create health bar fill
    this.healthBar = this.add
      .rectangle(45, 30, 150, 18, 0x00cc66)
      .setOrigin(0, 0.5);

    // Health label
    this.add
      .text(35, 30, "Health:", {
        font: "14px Arial",
        fill: "#ffffff",
      })
      .setOrigin(1, 0.5);

    // Create combo counter
    this.comboText = this.add
      .text(width / 2, height - 50, "Combo: 0", {
        font: "18px Arial",
        fill: "#ffbb00",
      })
      .setOrigin(0.5);

    // Add back button
    const backButton = this.add
      .rectangle(100, height - 20, 150, 30, 0x3d3d3d)
      .setStrokeStyle(1, 0x5d5d5d)
      .setInteractive({ useHandCursor: true })
      .on("pointerover", () => backButton.setFillStyle(0x4d4d4d))
      .on("pointerout", () => backButton.setFillStyle(0x3d3d3d))
      .on("pointerdown", () => this.returnToMainGame(false));

    this.add
      .text(100, height - 20, "BACK TO GAME", {
        font: "14px Arial",
        fill: "#ffffff",
      })
      .setOrigin(0.5);

    // Create legend panel
    this.createLegend();
  }

  createLegend() {
    const { width, height } = this.cameras.main;

    // Legend panel at the right side
    const legendPanel = this.add
      .rectangle(width - 120, height / 2, 200, 300, 0x0c4a6e, 0.7)
      .setStrokeStyle(1, 0x0ea5e9);

    // Title
    this.add
      .text(width - 120, height / 2 - 130, "LEGEND", {
        font: "bold 16px Arial",
        fill: "#ffffff",
      })
      .setOrigin(0.5);

    // Malware section title
    this.add
      .text(width - 120, height / 2 - 100, "CLICK THESE (Malware):", {
        font: "12px Arial",
        fill: "#ff6666",
      })
      .setOrigin(0.5);

    // Show 4 malware types as examples
    const malwareExamples = ["virus", "trojan", "ransomware", "spyware"];
    malwareExamples.forEach((key, index) => {
      const y = height / 2 - 80 + index * 25;
      const malware = this.MALWARE_TYPES[key];

      this.add
        .text(width - 180, y, malware.icon, {
          font: "16px Arial",
        })
        .setOrigin(0.5);

      this.add
        .text(width - 150, y, malware.name, {
          font: "14px Arial",
          fill: "#ffffff",
        })
        .setOrigin(0, 0.5);
    });

    // Safe files section title
    this.add
      .text(width - 120, height / 2 + 20, "DON'T CLICK (Safe Files):", {
        font: "12px Arial",
        fill: "#00cc66",
      })
      .setOrigin(0.5);

    // Show 4 legitimate file types
    const fileExamples = ["document", "image", "folder", "application"];
    fileExamples.forEach((key, index) => {
      const y = height / 2 + 40 + index * 25;
      const file = this.LEGITIMATE_FILES[key];

      this.add
        .text(width - 180, y, file.icon, {
          font: "16px Arial",
        })
        .setOrigin(0.5);

      this.add
        .text(width - 150, y, file.name, {
          font: "14px Arial",
          fill: "#ffffff",
        })
        .setOrigin(0, 0.5);
    });
  }

  startCountdown() {
    // "Get Ready" countdown before the game starts
    const { width, height } = this.cameras.main;

    // Create countdown overlay
    const overlay = this.add.rectangle(
      width / 2,
      height / 2,
      width,
      height,
      0x000000,
      0.7
    );

    // Countdown text
    const countdownText = this.add
      .text(width / 2, height / 2, "3", {
        font: "bold 80px Arial",
        fill: "#ffffff",
      })
      .setOrigin(0.5);

    // Get ready text
    this.add
      .text(width / 2, height / 2 - 100, "GET READY!", {
        font: "bold 40px Arial",
        fill: "#00cc66",
      })
      .setOrigin(0.5);

    // Countdown sequence
    let count = 3;
    const countdownTimer = this.time.addEvent({
      delay: 1000,
      callback: () => {
        count--;

        if (count > 0) {
          countdownText.setText(count.toString());
        } else {
          countdownText.setText("GO!");

          // Hide countdown and start game after brief pause
          this.time.delayedCall(500, () => {
            overlay.destroy();
            countdownText.destroy();
            this.startGame();
          });
        }
      },
      callbackScope: this,
      repeat: 3,
    });
  }

  startGame() {
    this.gameState = "playing";

    // Start timer
    this.countdownTimer = this.time.addEvent({
      delay: 1000,
      callback: this.updateTimer,
      callbackScope: this,
      loop: true,
    });

    // Start spawning items
    this.spawnTimer = this.time.addEvent({
      delay: this.spawnDelay,
      callback: this.spawnRandomItem,
      callbackScope: this,
      loop: true,
    });
  }

  updateTimer() {
    this.timeLeft--;
    this.timerText.setText(`Time: ${this.timeLeft}s`);

    // Make spawning faster over time
    if (this.timeLeft % 5 === 0 && this.spawnDelay > this.minSpawnDelay) {
      this.spawnDelay = Math.max(this.minSpawnDelay, this.spawnDelay - 200);
      this.spawnTimer.delay = this.spawnDelay;
      console.log(`Spawn delay reduced to ${this.spawnDelay}ms`);
    }

    // Time's up
    if (this.timeLeft <= 0) {
      this.countdownTimer.remove();

      if (this.spawnTimer) {
        this.spawnTimer.remove();
      }

      this.gameOver();
      return;
    }

    // Make timer text red when time is running out
    if (this.timeLeft <= 5) {
      this.timerText.setColor("#ff3333");

      // Add pulsing animation when time is low
      if (this.timeLeft === 5) {
        this.tweens.add({
          targets: this.timerText,
          scale: { from: 1, to: 1.2 },
          duration: 500,
          yoyo: true,
          repeat: 4,
        });
      }
    }
  }

  spawnRandomItem() {
    if (this.gameState !== "playing") return;

    // Determine if this will be malware or legitimate file
    // Higher chance of malware as game progresses
    const malwareChance = 0.6 + 0.2 * (1 - this.timeLeft / 30);
    const isMalware = Math.random() < malwareChance;

    let itemType, itemData;

    if (isMalware) {
      // Select random malware type
      const malwareTypes = Object.keys(this.MALWARE_TYPES);
      itemType = malwareTypes[Math.floor(Math.random() * malwareTypes.length)];
      itemData = this.MALWARE_TYPES[itemType];
    } else {
      // Select random legitimate file type
      const fileTypes = Object.keys(this.LEGITIMATE_FILES);
      itemType = fileTypes[Math.floor(Math.random() * fileTypes.length)];
      itemData = this.LEGITIMATE_FILES[itemType];
    }

    this.createItem(itemType, itemData, isMalware);
    this.itemsSpawned++;
  }

  createItem(itemType, itemData, isMalware) {
    const { width, height } = this.cameras.main;

    // Generate random position within the game area
    const x = this.gameAreaX + Math.random() * this.gameAreaWidth;
    const y = this.gameAreaY + Math.random() * this.gameAreaHeight;

    // Create item container
    const container = this.add.container(x, y);

    // Create window-like background
    const bg = this.add
      .rectangle(0, 0, 100, 120, 0xffffff, 0.9)
      .setStrokeStyle(1, isMalware ? 0xff3333 : 0x0ea5e9);

    // Window title bar
    const titleBar = this.add.rectangle(
      0,
      -50,
      100,
      20,
      isMalware ? 0xff3333 : 0x0ea5e9
    );

    // Item icon
    const icon = this.add
      .text(0, -10, itemData.icon, {
        font: "40px Arial",
      })
      .setOrigin(0.5);

    // Item name
    const name = this.add
      .text(0, 30, itemData.name, {
        font: "12px Arial",
        fill: "#000000",
      })
      .setOrigin(0.5);

    // Add close button
    const closeBtn = this.add
      .text(40, -50, "‚úï", {
        font: "14px Arial",
        fill: "#ffffff",
      })
      .setOrigin(0.5);

    // Add file extension
    let extension = "";
    if (!isMalware) {
      switch (itemType) {
        case "document":
          extension = ".doc";
          break;
        case "image":
          extension = ".jpg";
          break;
        case "application":
          extension = ".exe";
          break;
        case "pdf":
          extension = ".pdf";
          break;
        case "music":
          extension = ".mp3";
          break;
        case "video":
          extension = ".mp4";
          break;
        default:
          extension = ".file";
      }
    } else {
      // Add suspicious extensions to malware
      const malwareExt = [".exe", ".bat", ".scr", ".cmd", ".vbs"];
      extension = malwareExt[Math.floor(Math.random() * malwareExt.length)];
    }

    const fileText = this.add
      .text(0, 50, `${itemType}${extension}`, {
        font: "10px Arial",
        fill: "#000000",
      })
      .setOrigin(0.5);

    // Make whole window interactive
    bg.setInteractive({ useHandCursor: true }).on("pointerdown", () => {
      this.itemClicked(container, itemType, itemData, isMalware);
    });

    // Add components to container
    container.add([bg, titleBar, icon, name, fileText, closeBtn]);

    // Add entry animation
    container.setScale(0);
    this.tweens.add({
      targets: container,
      scale: { from: 0, to: 1 },
      alpha: { from: 0, to: 1 },
      duration: 200,
      ease: "Back.easeOut",
    });

    // Auto-remove after lifespan
    const removeTimer = this.time.delayedCall(this.itemLifespan, () => {
      if (container.active) {
        // If this was malware and not clicked, penalize player
        if (isMalware) {
          this.malwareMissed++;
          this.reduceHealth(10);
          this.resetCombo();

          // Show miss indicator
          this.showMissIndicator(container.x, container.y);
        }

        this.removeItem(container);
      }
    });

    // Store item data
    this.activeItems.push({
      container,
      type: itemType,
      isMalware,
      removeTimer,
    });
  }

  itemClicked(container, itemType, itemData, isMalware) {
    // Find the item in our active items
    const itemIndex = this.activeItems.findIndex(
      (item) => item.container === container
    );
    if (itemIndex === -1) return;

    // Stop the auto-remove timer
    this.activeItems[itemIndex].removeTimer.remove();

    if (isMalware) {
      // Correctly clicked on malware - give points
      this.score += itemData.points;
      this.scoreText.setText(`Score: ${this.score}`);
      this.malwareClicked++;

      // Increment combo
      this.comboCount++;
      this.maxComboCount = Math.max(this.maxComboCount, this.comboCount);
      this.comboText.setText(`Combo: ${this.comboCount}`);

      // Apply combo effect
      if (this.comboCount > 1) {
        // Bonus points for combo
        const comboBonus = Math.min(this.comboCount, 5); // Max 5x bonus
        this.score += comboBonus;
        this.scoreText.setText(`Score: ${this.score}`);

        // Scale up combo text
        this.tweens.add({
          targets: this.comboText,
          scale: { from: 1, to: 1.2 },
          duration: 200,
          yoyo: true,
        });
      }

      // Show success animation
      this.showSuccessAnimation(container.x, container.y);

      // Play success sound
      this.game.soundManager.play("button-click");
    } else {
      // Incorrectly clicked on legitimate file - penalty
      this.score = Math.max(0, this.score - itemData.penalty);
      this.scoreText.setText(`Score: ${this.score}`);
      this.legitimateClicked++;

      // Reset combo
      this.resetCombo();

      // Reduce health
      this.reduceHealth(5);

      // Show failure animation
      this.showFailureAnimation(container.x, container.y);

      // Play failure sound
      this.game.soundManager.play("failure");
    }

    // Remove the item
    this.removeItem(container);
  }

  removeItem(container) {
    // Find the item in our active items
    const itemIndex = this.activeItems.findIndex(
      (item) => item.container === container
    );
    if (itemIndex === -1) return;

    // Removal animation
    this.tweens.add({
      targets: container,
      scale: { from: 1, to: 0 },
      alpha: { from: 1, to: 0 },
      duration: 200,
      onComplete: () => {
        container.destroy();
      },
    });

    // Remove from our tracking array
    this.activeItems.splice(itemIndex, 1);
  }

  resetCombo() {
    this.comboCount = 0;
    this.comboText.setText(`Combo: ${this.comboCount}`);

    // Visual effect for combo reset
    this.tweens.add({
      targets: this.comboText,
      alpha: { from: 0.5, to: 1 },
      duration: 300,
    });
  }

  reduceHealth(amount) {
    // Reduce system health
    this.systemHealth = Math.max(0, this.systemHealth - amount);

    // Update health bar
    this.tweens.add({
      targets: this.healthBar,
      width: (this.systemHealth / 100) * 150,
      duration: 200,
    });

    // Change color based on health level
    if (this.systemHealth < 30) {
      this.healthBar.fillColor = 0xff3333; // Red
    } else if (this.systemHealth < 60) {
      this.healthBar.fillColor = 0xffcc00; // Yellow
    }

    // Check for game over
    if (this.systemHealth <= 0) {
      this.systemHealth = 0;

      // Stop the game
      if (this.countdownTimer) {
        this.countdownTimer.remove();
      }

      if (this.spawnTimer) {
        this.spawnTimer.remove();
      }

      this.gameOver();
    }
  }

  showSuccessAnimation(x, y) {
    // Create success indicator
    const success = this.add
      .text(x, y, "‚úì", {
        font: "bold 40px Arial",
        fill: "#00cc66",
      })
      .setOrigin(0.5);

    // Animation
    this.tweens.add({
      targets: success,
      scale: { from: 0.5, to: 1.5 },
      alpha: { from: 1, to: 0 },
      y: "-=50",
      duration: 500,
      onComplete: () => {
        success.destroy();
      },
    });
  }

  showFailureAnimation(x, y) {
    // Create failure indicator
    const failure = this.add
      .text(x, y, "‚úó", {
        font: "bold 40px Arial",
        fill: "#ff3333",
      })
      .setOrigin(0.5);

    // Animation
    this.tweens.add({
      targets: failure,
      scale: { from: 0.5, to: 1.5 },
      alpha: { from: 1, to: 0 },
      y: "-=50",
      duration: 500,
      onComplete: () => {
        failure.destroy();
      },
    });
  }

  showMissIndicator(x, y) {
    // Create miss indicator
    const miss = this.add
      .text(x, y, "MISSED!", {
        font: "bold 16px Arial",
        fill: "#ff6600",
      })
      .setOrigin(0.5);

    // Animation
    this.tweens.add({
      targets: miss,
      scale: { from: 0.5, to: 1 },
      alpha: { from: 1, to: 0 },
      y: "-=30",
      duration: 800,
      onComplete: () => {
        miss.destroy();
      },
    });
  }

  gameOver() {
    this.gameState = "gameOver";

    // Stop all timers
    if (this.countdownTimer) {
      this.countdownTimer.remove();
    }

    if (this.spawnTimer) {
      this.spawnTimer.remove();
    }

    // Clear any remaining items with a quick fadeout
    this.activeItems.forEach((item) => {
      this.tweens.add({
        targets: item.container,
        alpha: 0,
        duration: 300,
        onComplete: () => {
          item.container.destroy();
        },
      });
    });
    this.activeItems = [];

    // Calculate success based on health and score
    const success = this.systemHealth > 0 || this.score >= 100;

    // Calculate statistics
    const accuracy =
      this.malwareClicked + this.legitimateClicked > 0
        ? Math.round(
            (this.malwareClicked /
              (this.malwareClicked + this.legitimateClicked)) *
              100
          )
        : 0;

    const detectionRate =
      this.malwareClicked + this.malwareMissed > 0
        ? Math.round(
            (this.malwareClicked / (this.malwareClicked + this.malwareMissed)) *
              100
          )
        : 0;

    // Show results
    if (success) {
      this.showSuccessResults(accuracy, detectionRate);
    } else {
      this.showFailureResults(accuracy, detectionRate);
    }
  }

  showSuccessResults(accuracy, detectionRate) {
    const { width, height } = this.cameras.main;

    // Create overlay
    const overlay = this.add.rectangle(
      width / 2,
      height / 2,
      width,
      height,
      0x000000,
      0.7
    );

    // Create results panel
    const panel = this.add
      .rectangle(width / 2, height / 2, 400, 350, 0x002222)
      .setStrokeStyle(3, 0x00ff88);

    // Title
    const title = this.add
      .text(width / 2, height / 2 - 130, "SYSTEM SECURED!", {
        font: "bold 28px Arial",
        fill: "#00cc66",
      })
      .setOrigin(0.5);

    // Results
    const healthText = this.add
      .text(
        width / 2,
        height / 2 - 80,
        `System Health: ${this.systemHealth}%`,
        {
          font: "18px Arial",
          fill: "#ffffff",
        }
      )
      .setOrigin(0.5);

    const accuracyText = this.add
      .text(width / 2, height / 2 - 50, `Click Accuracy: ${accuracy}%`, {
        font: "18px Arial",
        fill: "#ffffff",
      })
      .setOrigin(0.5);

    const detectionText = this.add
      .text(
        width / 2,
        height / 2 - 20,
        `Malware Detection: ${detectionRate}%`,
        {
          font: "18px Arial",
          fill: "#ffffff",
        }
      )
      .setOrigin(0.5);

    const comboText = this.add
      .text(width / 2, height / 2 + 10, `Max Combo: ${this.maxComboCount}`, {
        font: "18px Arial",
        fill: "#ffdd00",
      })
      .setOrigin(0.5);

    // Calculate bonuses
    const healthBonus = Math.round(this.systemHealth / 2);
    const accuracyBonus = Math.round(accuracy / 2);
    const detectionBonus = Math.round(detectionRate / 2);
    const comboBonus = this.maxComboCount * 5;
    const totalBonus =
      healthBonus + accuracyBonus + detectionBonus + comboBonus;

    const healthBonusText = this.add
      .text(width / 2, height / 2 + 40, `Health Bonus: +${healthBonus}`, {
        font: "16px Arial",
        fill: "#00cc66",
      })
      .setOrigin(0.5);

    const accuracyBonusText = this.add
      .text(width / 2, height / 2 + 65, `Accuracy Bonus: +${accuracyBonus}`, {
        font: "16px Arial",
        fill: "#00cc66",
      })
      .setOrigin(0.5);

    const detectionBonusText = this.add
      .text(width / 2, height / 2 + 90, `Detection Bonus: +${detectionBonus}`, {
        font: "16px Arial",
        fill: "#00cc66",
      })
      .setOrigin(0.5);

    const comboBonusText = this.add
      .text(width / 2, height / 2 + 115, `Combo Bonus: +${comboBonus}`, {
        font: "16px Arial",
        fill: "#ffdd00",
      })
      .setOrigin(0.5);

    // Add bonuses to score
    this.score += totalBonus;

    const totalBonusText = this.add
      .text(width / 2, height / 2 + 145, `TOTAL BONUS: +${totalBonus}`, {
        font: "bold 18px Arial",
        fill: "#00aaff",
      })
      .setOrigin(0.5);

    const finalScoreText = this.add
      .text(width / 2, height / 2 + 175, `FINAL SCORE: ${this.score}`, {
        font: "bold 22px Arial",
        fill: "#00aaff",
      })
      .setOrigin(0.5);

    // Continue button
    const continueButton = this.add
      .rectangle(width / 2, height / 2 + 215, 200, 50, 0x00aa66)
      .setStrokeStyle(2, 0x00cc88)
      .setInteractive({ useHandCursor: true })
      .on("pointerover", () => continueButton.setFillStyle(0x00bb77))
      .on("pointerout", () => continueButton.setFillStyle(0x00aa66))
      .on("pointerdown", () => this.returnToMainGame(true));

    const continueText = this.add
      .text(width / 2, height / 2 + 215, "CONTINUE", {
        font: "bold 20px Arial",
        fill: "#ffffff",
      })
      .setOrigin(0.5);

    // Play success sound
    this.game.soundManager.play("success");
  }

  showFailureResults(accuracy, detectionRate) {
    const { width, height } = this.cameras.main;

    // Create overlay
    const overlay = this.add.rectangle(
      width / 2,
      height / 2,
      width,
      height,
      0x000000,
      0.7
    );

    // Create results panel
    const panel = this.add
      .rectangle(width / 2, height / 2, 400, 300, 0x220000)
      .setStrokeStyle(3, 0xff3333);

    // Title
    const title = this.add
      .text(width / 2, height / 2 - 100, "SYSTEM COMPROMISED!", {
        font: "bold 28px Arial",
        fill: "#ff3333",
      })
      .setOrigin(0.5);

    // Results
    const healthText = this.add
      .text(
        width / 2,
        height / 2 - 60,
        `System Health: ${this.systemHealth}%`,
        {
          font: "18px Arial",
          fill: "#ffffff",
        }
      )
      .setOrigin(0.5);

    const accuracyText = this.add
      .text(width / 2, height / 2 - 30, `Click Accuracy: ${accuracy}%`, {
        font: "18px Arial",
        fill: "#ffffff",
      })
      .setOrigin(0.5);

    const detectionText = this.add
      .text(width / 2, height / 2, `Malware Detection: ${detectionRate}%`, {
        font: "18px Arial",
        fill: "#ffffff",
      })
      .setOrigin(0.5);

    // Tips based on problems
    let tipText = "";
    if (detectionRate < 70) {
      tipText = "Tip: Click on malware faster to prevent system infection!";
    } else if (accuracy < 70) {
      tipText = "Tip: Be more careful not to click on legitimate files!";
    } else {
      tipText = "Tip: Keep an eye on your system health while playing!";
    }

    this.add
      .text(width / 2, height / 2 + 30, tipText, {
        font: "16px Arial",
        fill: "#ffdd00",
      })
      .setOrigin(0.5);

    const scoreText = this.add
      .text(width / 2, height / 2 + 60, `FINAL SCORE: ${this.score}`, {
        font: "bold 22px Arial",
        fill: "#00aaff",
      })
      .setOrigin(0.5);

    // Try again button
    const tryAgainButton = this.add
      .rectangle(width / 2, height / 2 + 110, 200, 50, 0xaa0000)
      .setStrokeStyle(2, 0xff3333)
      .setInteractive({ useHandCursor: true })
      .on("pointerover", () => tryAgainButton.setFillStyle(0xcc0000))
      .on("pointerout", () => tryAgainButton.setFillStyle(0xaa0000))
      .on("pointerdown", () => this.restartMiniGame());

    const tryAgainText = this.add
      .text(width / 2, height / 2 + 110, "TRY AGAIN", {
        font: "bold 20px Arial",
        fill: "#ffffff",
      })
      .setOrigin(0.5);

    // Play failure sound
    this.game.soundManager.play("failure");
  }

  restartMiniGame() {
    // Reset game state
    this.systemHealth = 100;
    this.comboCount = 0;
    this.maxComboCount = 0;
    this.timeLeft = 30;
    this.spawnDelay = 2000;
    this.itemsSpawned = 0;
    this.malwareClicked = 0;
    this.malwareMissed = 0;
    this.legitimateClicked = 0;

    // Reset health bar
    this.healthBar.width = 150;
    this.healthBar.fillColor = 0x00cc66;

    // Reset UI
    this.timerText.setText(`Time: ${this.timeLeft}s`);
    this.timerText.setColor("#ffdd00");
    this.timerText.setScale(1);
    this.comboText.setText("Combo: 0");
    this.comboText.setScale(1);

    // Clear any remaining items
    this.activeItems.forEach((item) => {
      if (item.removeTimer) {
        item.removeTimer.remove();
      }
      if (item.container) {
        item.container.destroy();
      }
    });
    this.activeItems = [];

    // Start the countdown again
    this.startCountdown();
  }

  returnToMainGame(success) {
    // Stop any running timers
    if (this.countdownTimer) {
      this.countdownTimer.remove();
    }

    if (this.spawnTimer) {
      this.spawnTimer.remove();
    }

    // Clear any remaining items
    this.activeItems.forEach((item) => {
      if (item.removeTimer) {
        item.removeTimer.remove();
      }
      if (item.container) {
        item.container.destroy();
      }
    });

    // Make sure we properly return to the main game with results
    if (this.returnCallback) {
      // Call the callback function with the success status and score
      this.returnCallback(success, this.score);

      // Resume the main scene and hide this one
      this.scene.resume("GameScene");
      this.scene.stop();
    } else {
      // Fallback to direct scene transition if callback is not available
      this.scene.start("GameScene", {
        miniGameSuccess: success,
        score: this.score,
        row: this.row,
        col: this.col,
        threatType: this.threatType,
      });
    }
  }

  update() {
    // Game update logic - we're using timers for most things
    // but could add particle effects or other dynamic visuals here
  }
}
